
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DslShell = global::Microsoft.VisualStudio.Modeling.Shell;
using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslValidation = global::Microsoft.VisualStudio.Modeling.Validation;
using DslDiagrams = global::Microsoft.VisualStudio.Modeling.Diagrams;
using VSShellInterop = global::Microsoft.VisualStudio.Shell.Interop;

namespace DSLFactory.Candle.SystemModel
{
	/// <summary>
	/// Double-derived class to allow easier code customization.
	/// </summary>
	internal partial class CandleDocData : CandleDocDataBase
	{
		/// <summary>
		/// Constructs a new CandleDocData.
		/// </summary>
		public CandleDocData(global::System.IServiceProvider serviceProvider, global::System.Guid editorFactoryId) 
			: base(serviceProvider, editorFactoryId)
		{
		}
	}

	/// <summary>
	/// Class which represents a Candle document in memory.
	/// </summary>
	internal abstract class CandleDocDataBase : DslShell::ModelingDocData, VSShellInterop::IVsRunningDocTableEvents
	{

		#region Constraint ValidationController
		/// <summary>
		/// The controller for all validation that goes on in the package.
		/// </summary>
		private DslShell::VsValidationController validationController;
		private DslShell::ErrorListObserver errorListObserver;
		#endregion
		/// <summary>
		/// Document lock holder registered for the subordinate .diagram file.
		/// </summary>
		private DslShell::SubordinateDocumentLockHolder diagramDocumentLockHolder;

		/// <summary>
		/// Cookie to handle RDT events callback
		/// </summary>
		private uint eventsCookie;

		/// <summary>
		/// Flag to restore subordinate file to the project
		/// </summary>
		private bool restoreSubordinateFile;
		/// <summary>
		/// Constructs a new CandleDocDataBase.
		/// </summary>
		protected CandleDocDataBase(global::System.IServiceProvider serviceProvider, global::System.Guid editorFactoryId) : base(serviceProvider, editorFactoryId)
		{
		}

		/// <summary>
		/// Returns a list of file format specifiers for the Save dialog box.
		/// </summary>
		protected override string FormatList
		{
			get
			{
                return global::DSLFactory.Candle.SystemModel.CandleDomainModel.SingletonResourceManager.GetString("FormatList"); 
			}
		}


		/// <summary>
		/// The controller for all validation that goes on in the package.
		/// </summary>
		public DslShell::VsValidationController ValidationController
		{
			get
			{
				if (this.validationController == null)
				{
					this.validationController = this.CreateValidationController();
					this.errorListObserver = new DslShell::ErrorListObserver(this.ServiceProvider);

					// register the observer so we can show the error/warning/msg in the VS output window.
					this.validationController.AddObserver(this.errorListObserver);
				}
				return this.validationController;
			}
		}

		/// <summary>
		/// Factory method to create a VSValidationController.
		/// </summary>
		protected virtual DslShell::VsValidationController CreateValidationController()
		{
			return new DslShell::VsValidationController(this.ServiceProvider, typeof(CandleExplorerToolWindow));
		}
		
		/// <summary>
		/// When the doc data is closed, make sure we reset the valiation messages 
		/// (if there's any) from the ErrorList window.
		/// </summary>
		/// <param name="disposing"></param>
		protected override void Dispose(bool disposing)
		{
			try
			{
				if (this.validationController != null)
				{
					this.validationController.ClearMessages();
					// un-register our observer with the controller.
					this.validationController.RemoveObserver(this.errorListObserver);
					this.validationController = null;
					if ( this.errorListObserver != null )
					{
						this.errorListObserver.Dispose();
						this.errorListObserver = null;
					}
				}
				if (this.diagramDocumentLockHolder != null)
				{
					this.diagramDocumentLockHolder.Dispose();
					this.diagramDocumentLockHolder = null;
				}
				if (this.eventsCookie != 0)
				{
					DslShell::SubordinateFileHelper.UnadviseRunningDocumentTableEvents(this.ServiceProvider, this.eventsCookie);
					this.eventsCookie = 0;
				}
			}
			finally
			{
				base.Dispose(disposing);
			}
		}

		/// <summary>
		/// Returns a collection of domain models to load into the store.
		/// </summary>
		protected override global::System.Collections.Generic.IList<global::System.Type> GetDomainModels()
		{
			return new global::System.Type[]
			{
				typeof(DslDiagrams::CoreDesignSurfaceDomainModel),
				typeof(global::DSLFactory.Candle.SystemModel.CandleDomainModel)
			};
		}

		/// <summary>
		/// Loads the given file.
		/// </summary>
		protected override void Load(string fileName, bool isReload)
		{
			DslModeling::SerializationResult serializationResult = new DslModeling::SerializationResult();
			global::DSLFactory.Candle.SystemModel.CandleModel modelRoot = null;
			DslModeling::ISchemaResolver schemaResolver = new DslShell::ModelingSchemaResolver(this.ServiceProvider);
			
			// Enable diagram fixup rules in our store, because we will load diagram data.
			global::DSLFactory.Candle.SystemModel.CandleDomainModel.EnableDiagramRules(this.Store);
			string diagramFileName = fileName + this.DiagramExtension;
			
			// Ensure that subordinate diagram file is named properly; handles the case where a rename occurs while the designer was closed.
			if(this.Hierarchy != null)
			{
				uint itemId = DslShell::SubordinateFileHelper.GetChildProjectItemId(this.Hierarchy, this.ItemId, this.DiagramExtension);
				if(itemId != global::Microsoft.VisualStudio.VSConstants.VSITEMID_NIL)
				{
					global::System.Diagnostics.Debug.Assert(!this.IsLoaded);
					// Make sure the name is right before we lock the item in the RDT.
					DslShell::SubordinateFileHelper.EnsureChildFileName(this.ServiceProvider, this.Hierarchy, itemId, diagramFileName);

					// Found the diagram file, lock it in the running documents table.
					this.diagramDocumentLockHolder = DslShell::SubordinateFileHelper.LockSubordinateDocument(this.ServiceProvider, this, diagramFileName, itemId);
					if (this.diagramDocumentLockHolder == null)
					{
						throw new global::System.InvalidOperationException(global::DSLFactory.Candle.SystemModel.CandleDomainModel.SingletonResourceManager.GetString("CannotOpenDocument"));
					}
				}
			}
			
			try
			{
				modelRoot = global::DSLFactory.Candle.SystemModel.CandleSerializationHelper.Instance.LoadModelAndDiagram(serializationResult, this.Store, fileName, diagramFileName, schemaResolver, null /* no load-time validation */);
			}
			finally
			{
				if (this.diagramDocumentLockHolder != null && (modelRoot == null || serializationResult.Failed))
				{
					// Load failed, release the document lock if we added one above.
					this.diagramDocumentLockHolder.UnregisterSubordinateDocument();
					this.diagramDocumentLockHolder = null;
				}
			}

			// Report serialization messages.
			this.SuspendErrorListRefresh();
			try
			{
				foreach (DslModeling::SerializationMessage serializationMessage in serializationResult)
				{
					this.AddErrorListItem(new DslShell::SerializationErrorListItem(this.ServiceProvider, serializationMessage));
				}
			}
			finally
			{
				this.ResumeErrorListRefresh();
			}

			if (serializationResult.Failed)
			{	
				// Load failed, can't open the file.
				throw new global::System.InvalidOperationException(global::DSLFactory.Candle.SystemModel.CandleDomainModel.SingletonResourceManager.GetString("CannotOpenDocument"));
			}
			else
			{
				this.SetRootElement(modelRoot);
				if (this.Hierarchy != null && global::System.IO.File.Exists(diagramFileName))
				{
					DslShell::SubordinateFileHelper.EnsureChildProjectItem(this.Hierarchy, this.ItemId, diagramFileName);

					// Should have a subordinate diagram file now. If we didn't add a lock above, add one now.
					if (this.diagramDocumentLockHolder == null)
					{
						uint itemId = DslShell::SubordinateFileHelper.GetChildProjectItemId(this.Hierarchy, this.ItemId, this.DiagramExtension);
						this.diagramDocumentLockHolder = DslShell::SubordinateFileHelper.LockSubordinateDocument(this.ServiceProvider, this, diagramFileName, itemId);
						if (this.diagramDocumentLockHolder == null)
						{
							throw new global::System.InvalidOperationException(global::DSLFactory.Candle.SystemModel.CandleDomainModel.SingletonResourceManager.GetString("CannotOpenDocument"));
						}
					}

					// Connect to events on the RDT in order to allow delayed rename handling.
					this.eventsCookie = DslShell::SubordinateFileHelper.AdviseRunningDocumentTableEvents(this.ServiceProvider, this);
				}
			}
		}

		/// <summary>
		/// Called after the document is opened.
		/// </summary>
		/// <param name="e">Event Args.</param>
		protected override void OnDocumentLoaded(global::System.EventArgs e)
		{
			base.OnDocumentLoaded(e);
			this.OnDocumentLoaded();
		}

		/// <summary>
		/// Called after the document is reloaded.
		/// </summary>
		protected override void OnDocumentReloaded(global::System.EventArgs e)
		{
			base.OnDocumentReloaded(e);
			this.OnDocumentLoaded();
		}
		
		/// <summary>
		/// Called on both document load and reload.
		/// </summary>
		protected virtual void OnDocumentLoaded()
		{

			// Validate the document
			this.ValidationController.Validate(this.Store, DslValidation::ValidationCategories.Open);

			// Enable CompartmentItems events.
			global::DSLFactory.Candle.SystemModel.CandleModel modelRoot = this.RootElement as global::DSLFactory.Candle.SystemModel.CandleModel;
			if (modelRoot != null)
			{
				global::System.Collections.Generic.IList<DslDiagrams::PresentationElement> diagrams = DslDiagrams::PresentationViewsSubject.GetPresentation(modelRoot);
				if (diagrams.Count > 0)
				{
					global::DSLFactory.Candle.SystemModel.ComponentModelDiagram diagram = diagrams[0] as global::DSLFactory.Candle.SystemModel.ComponentModelDiagram;
					if (diagram != null)
					{
						diagram.SubscribeCompartmentItemsEvents();
					}
				}
			}
		}


		/// <summary>
		/// Validate the model before the file is saved.
		/// </summary>
		protected override bool CanSave(bool allowUserInterface)
		{
			global::System.Windows.Forms.DialogResult result = global::System.Windows.Forms.DialogResult.Yes;
			
			// Do not call validation in the case of a silent save, because the user cannot be prompted.
			if (allowUserInterface)
			{
				// We check Load category first, because any violation in this category will cause the saved file to be unloadable, so we want to a special 
				// error message for that. If the Load category passes, we then check the normal Save category, and give the normal warning message if 
				// necessary.
				bool unloadableError = false;
				if (!this.ValidationController.Validate(this.Store, DslValidation::ValidationCategories.Load) && this.ValidationController.ErrorMessages.Count != 0)
				{	// Check Load category
					unloadableError = true;
				}
				if ((!this.ValidationController.Validate(this.Store, DslValidation::ValidationCategories.Save) && this.ValidationController.ErrorMessages.Count != 0) || unloadableError)
				{	// Check Save category
					string errorMsg = (unloadableError ? "UnloadableSaveValidationFailed" : "SaveValidationFailed");
					result = DslShell::PackageUtility.ShowMessageBox(this.ServiceProvider, global::DSLFactory.Candle.SystemModel.CandleDomainModel.SingletonResourceManager.GetString(errorMsg), VSShellInterop::OLEMSGBUTTON.OLEMSGBUTTON_YESNO, VSShellInterop::OLEMSGDEFBUTTON.OLEMSGDEFBUTTON_SECOND, VSShellInterop::OLEMSGICON.OLEMSGICON_WARNING);
				}
			}

			return (result == global::System.Windows.Forms.DialogResult.Yes);
		}

			
		/// <summary>
		/// Handle when document has been saved
		/// </summary>
		/// <param name="e"></param>
		protected override void OnDocumentSaved(System.EventArgs e)
		{
			base.OnDocumentSaved(e);

			// Notify the Running Document Table that the subordinate has been saved
			if (this.ServiceProvider != null)
			{
				VSShellInterop::IVsRunningDocumentTable rdt = (VSShellInterop.IVsRunningDocumentTable)this.ServiceProvider.GetService(typeof(VSShellInterop::IVsRunningDocumentTable));
				if (rdt != null && this.diagramDocumentLockHolder != null && this.diagramDocumentLockHolder.SubordinateDocData != null)
				{
					global::Microsoft.VisualStudio.ErrorHandler.ThrowOnFailure(rdt.NotifyOnAfterSave(this.diagramDocumentLockHolder.SubordinateDocData.Cookie));
				}
			}
		}

		/// <summary>
		/// Saves the given file.
		/// </summary>
		protected override void Save(string fileName)
		{
			DslModeling::SerializationResult serializationResult = new DslModeling::SerializationResult();
			global::DSLFactory.Candle.SystemModel.CandleModel modelRoot = (global::DSLFactory.Candle.SystemModel.CandleModel)this.RootElement;

			
			global::System.Collections.Generic.IList<DslDiagrams::PresentationElement> diagrams = DslDiagrams::PresentationViewsSubject.GetPresentation(this.RootElement);
			if (diagrams.Count > 0)
			{
				global::DSLFactory.Candle.SystemModel.ComponentModelDiagram diagram = diagrams[0] as global::DSLFactory.Candle.SystemModel.ComponentModelDiagram;
				if (diagram != null)
				{
					string diagramFileName = fileName + this.DiagramExtension;
					
					try
					{
						this.SuspendFileChangeNotification(diagramFileName);
						
						global::DSLFactory.Candle.SystemModel.CandleSerializationHelper.Instance.SaveModelAndDiagram(serializationResult, modelRoot, fileName, diagram, diagramFileName, this.Encoding, false);
						if (!serializationResult.Failed)
						{
							// fileName != this.FileName is false in the case of Save As.  Allow OnFileNameChanged() below to handle this case.
							if (global::System.StringComparer.OrdinalIgnoreCase.Compare(fileName, this.FileName) == 0 && global::System.IO.File.Exists(diagramFileName))
							{
								DslShell::SubordinateFileHelper.EnsureChildProjectItem(this.Hierarchy, this.ItemId, diagramFileName);
							}
						}
					}
					finally
					{
						this.ResumeFileChangeNotification(diagramFileName);
					}
				}
			}
			if (!serializationResult.Failed)
			{
				global::DSLFactory.Candle.SystemModel.CandleSerializationHelper.Instance.SaveModel(serializationResult, modelRoot, fileName, this.Encoding, false);
			}
			// Report serialization messages.
			this.SuspendErrorListRefresh();
			try
			{
				foreach (DslModeling::SerializationMessage serializationMessage in serializationResult)
				{
					this.AddErrorListItem(new DslShell::SerializationErrorListItem(this.ServiceProvider, serializationMessage));
				}
			}
			finally
			{
				this.ResumeErrorListRefresh();
			}

			if (serializationResult.Failed)
			{	// Save failed.
				throw new global::System.InvalidOperationException(global::DSLFactory.Candle.SystemModel.CandleDomainModel.SingletonResourceManager.GetString("CannotSaveDocument"));
			}
		}

		#region Diagram file management
		
		private const string DefaultDiagramExtension = ".diagram";
		
		
		/// <summary>
		/// Provide a suffix for the diagram file
		/// </summary>
		protected virtual string DiagramExtension
		{
			get
			{
				return DefaultDiagramExtension;
			}
		}
		
		/// <summary>
		/// Propagates file name changes to the diagram file.
		/// </summary>
		protected override void OnFileNameChanged(global::System.EventArgs e)
		{
			base.OnFileNameChanged(e);

			if (this.IsLoaded && this.Hierarchy != null)
			{
				uint childId = DslShell::SubordinateFileHelper.GetChildProjectItemId(this.Hierarchy, this.ItemId, this.DiagramExtension);
				if (childId != global::Microsoft.VisualStudio.VSConstants.VSITEMID_NIL)
				{
					// If the file is loaded, then we should remove the subordinate file's lock and restore it after the rename.
					this.diagramDocumentLockHolder.UnregisterSubordinateDocument();
					this.diagramDocumentLockHolder = null;

					// Perform the rename
					DslShell::SubordinateFileHelper.EnsureChildFileName(this.ServiceProvider, this.Hierarchy, childId, this.FileName + this.DiagramExtension);

					// Because we've removed the file from the project and dropped our lock, make a note to put them back later via an event.
					// We don't do this here, as the SaveAs code in Visual Studio will query overwriting these files if they are in the project here.
					// We dont retake the lock here as Visual Studio will close the parent docdata if we delete from the project a locked item.
					this.restoreSubordinateFile = true;
				}
			}
		}
		#endregion

		#region IVsRunningDocTableEvents Members
		/// <summary>
		/// Replace the subordinate file in the project and create a new lock.
		/// </summary>
		private void RestoreSubordinateFile()
		{
			// The subordinate file may have been temporarily removed from the project.
			// Put it back if we were asked to.
			if (this.restoreSubordinateFile)
			{
				// Put the file back in the project
				DslShell::SubordinateFileHelper.EnsureChildProjectItem(this.Hierarchy, this.ItemId, this.FileName + this.DiagramExtension);

				// Get the new ChildId
				uint childId = DslShell::SubordinateFileHelper.GetChildProjectItemId(this.Hierarchy, this.ItemId, this.DiagramExtension);

				// Make a new lock
				this.diagramDocumentLockHolder = DslShell::SubordinateFileHelper.LockSubordinateDocument(this.ServiceProvider, this, childId);

				this.restoreSubordinateFile = false;
			}
		}

		/// <summary>
		/// Restore subordinate file if necessary after rename.
		/// </summary>
		/// <param name="docCookie"></param>
		/// <param name="grfAttribs"></param>
		/// <returns></returns>
		public int OnAfterAttributeChange(uint docCookie, uint grfAttribs)
		{
			// The subordinate file may have been temporarily removed from the project.
			// Put it back if we were asked to.
			this.RestoreSubordinateFile();
			return global::Microsoft.VisualStudio.VSConstants.S_OK;
		}

		/// <summary>
		/// OnAfterDocumentWindowHide
		/// </summary>
		/// <param name="docCookie"></param>
		/// <param name="pFrame"></param>
		/// <returns></returns>
		public int OnAfterDocumentWindowHide(uint docCookie, VSShellInterop::IVsWindowFrame pFrame)
		{
			// Do Nothing
			return global::Microsoft.VisualStudio.VSConstants.S_OK;
		}

		/// <summary>
		/// OnAfterFirstDocumentLock
		/// </summary>
		/// <param name="docCookie"></param>
		/// <param name="dwRDTLockType"></param>
		/// <param name="dwReadLocksRemaining"></param>
		/// <param name="dwEditLocksRemaining"></param>
		/// <returns></returns>
		public int OnAfterFirstDocumentLock(uint docCookie, uint dwRDTLockType, uint dwReadLocksRemaining, uint dwEditLocksRemaining)
		{
			// Do Nothing
			return global::Microsoft.VisualStudio.VSConstants.S_OK;
		}

		/// <summary>
		/// Restore subordinate file if necessary after SaveAs.
		/// </summary>
		/// <param name="docCookie"></param>
		/// <returns></returns>
		public int OnAfterSave(uint docCookie)
		{
			// The subordinate file may have been temporarily removed from the project.
			// Put it back if we were asked to.
			this.RestoreSubordinateFile();
			return global::Microsoft.VisualStudio.VSConstants.S_OK;
		}

		/// <summary>
		/// OnBeforeDocumentWindowShow
		/// </summary>
		/// <param name="docCookie"></param>
		/// <param name="fFirstShow"></param>
		/// <param name="pFrame"></param>
		/// <returns></returns>
		public int OnBeforeDocumentWindowShow(uint docCookie, int fFirstShow, VSShellInterop::IVsWindowFrame pFrame)
		{
			// Do Nothing
			return global::Microsoft.VisualStudio.VSConstants.S_OK;
		}

		/// <summary>
		/// OnBeforeLastDocumentUnlock
		/// </summary>
		/// <param name="docCookie"></param>
		/// <param name="dwRDTLockType"></param>
		/// <param name="dwReadLocksRemaining"></param>
		/// <param name="dwEditLocksRemaining"></param>
		/// <returns></returns>
		public int OnBeforeLastDocumentUnlock(uint docCookie, uint dwRDTLockType, uint dwReadLocksRemaining, uint dwEditLocksRemaining)
		{
			// Do Nothing
			return global::Microsoft.VisualStudio.VSConstants.S_OK;
		}
		#endregion
	}
}

